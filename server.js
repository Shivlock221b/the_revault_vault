const express = require('express');
const path = require('path');
const cors = require('cors');

const {
  createOrder,
  listOrders,
  getOrder,
  updateOrder,
  createRedemption,
  listRedemptions,
  approveRedemption,
  // New helpers imported from database for user, shop and configuration management
  createUser,
  getUser,
  updateUser,
  listUsers,
  createShop,
  listShops,
  getShop,
  updateShop,
  deleteShop,
  claimOrder,
  getGoldPrice,
  setGoldPrice,
  getDashboardData,
  // additional helpers for admin
  deleteUser,
  deleteOrder,
  // helpers for contact queries
  createQuery,
  listQueries,
  deleteQuery,
} = require('./database');

const app = express();
const PORT = process.env.PORT || 3000;
app.use(cors({
  origin: 'https://extensions.shopifycdn.com',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type'],
  credentials: true,
}));
// Middleware to parse JSON bodies
app.use(express.json());

// Serve static assets from the public directory. This includes our simple
// admin and dashboard HTML pages as well as any styles or images you add.
app.use(express.static(path.join(__dirname, 'public')));

/*
 * Configuration values for rewards. Adjust these values to change the
 * reward rate or the estimated price of gold. In a production
 * environment you would fetch the live gold price from a reliable
 * source instead of hard‑coding it.
 */
const REWARD_PERCENTAGE = 0.02; // 2 % of purchase total
const GOLD_PRICE_PER_GRAM = 6000; // rupees per gram

// Health check endpoint. Shopify pings this during app installation.
app.get('/ping', (_req, res) => {
  res.status(200).send('pong');
});

/**
 * POST /api/orders
 *
 * Create a new order and record the associated digital gold reward. The
 * request body should include the customer's email, a unique orderId
 * generated by Shopify, and the purchase total in rupees. The server
 * calculates the reward amount and weight, stores the record in the
 * database and returns the created object.
 */
app.post('/api/orders', async (req, res) => {
  const { shopId, shopName, orderId, totalPrice, orderNumber } = req.body;
  // if (!email || !orderId || typeof totalPrice === 'undefined') {
  //   return res
  //     .status(400)
  //     .json({ error: 'email, orderId and totalPrice are required.' });
  // }
  console.log("inside orders")
  console.log(req.body)
  const total = parseFloat(totalPrice);
  const rewardAmount = total * REWARD_PERCENTAGE;
  const rewardGrams = rewardAmount / GOLD_PRICE_PER_GRAM;
  try {
    const saved = await createOrder({
      shopId,
      shopName,
      orderId,
      orderNumber,
      purchaseTotal: total,
      rewardAmount,
      rewardGrams,
      status: 'pending',
      createdAt: new Date().toISOString(),
    });
    res.status(201).json(saved);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to create order' });
  }
});

/**
 * POST /api/users
 *
 * Create or update a user profile. Accepts an email and optional displayName.
 */
app.post('/api/users', async (req, res) => {
  const { email, displayName } = req.body;
  if (!email) {
    return res.status(400).json({ error: 'email is required' });
  }
  try {
    const user = await createUser({ email, displayName });
    res.status(201).json(user);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to create user' });
  }
});

/**
 * GET /api/users
 *
 * Return a list of all users. This endpoint is primarily for the admin
 * interface. No filters are provided at this time.
 */
app.get('/api/users', async (_req, res) => {
  try {
    const users = await listUsers();
    res.json(users);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

/**
 * GET /api/users/:email
 *
 * Retrieve a user by their email address. Returns 404 if the user isn't found.
 */
app.get('/api/users/:email', async (req, res) => {
  try {
    const user = await getUser(req.params.email);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch user' });
  }
});

/**
 * PUT /api/users/:email
 *
 * Update a user's profile. Accepts any fields to merge into the existing
 * document. Returns the updated user.
 */
app.put('/api/users/:email', async (req, res) => {
  try {
    const updated = await updateUser(req.params.email, req.body);
    res.json(updated);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to update user' });
  }
});

/**
 * DELETE /api/users/:email
 *
 * Delete a user by email. Returns success if deleted.
 */
app.delete('/api/users/:email', async (req, res) => {
  try {
    await deleteUser(req.params.email);
    res.json({ success: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to delete user' });
  }
});

/**
 * POST /api/orders/claim
 *
 * Assign an unclaimed order to a user. The request body should include
 * `orderId` and `email`. If the order is already claimed, the existing
 * assignment is preserved.
 */
app.post('/api/orders/claim', async (req, res) => {
  const { orderId, email } = req.body;
  if (!orderId || !email) {
    return res.status(400).json({ error: 'orderId and email are required' });
  }
  try {
    const updated = await claimOrder(orderId, email);
    if (!updated) {
      return res.status(404).json({ error: 'Order not found' });
    }
    res.json(updated);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to claim order' });
  }
});

/**
 * GET /api/dashboard
 *
 * Aggregate dashboard data for a given user. Requires an `email` query
 * parameter. Returns totals, redeemable grams, progress metrics,
 * a list of the user’s orders and available shops.
 */
app.get('/api/dashboard', async (req, res) => {
  const { email } = req.query;
  if (!email) {
    return res.status(400).json({ error: 'email query parameter is required' });
  }
  try {
    const data = await getDashboardData(email, GOLD_PRICE_PER_GRAM);
    res.json(data);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch dashboard data' });
  }
});

/**
 * GET /api/shops
 *
 * List all shops.
 */
app.get('/api/shops', async (_req, res) => {
  try {
    const shops = await listShops();
    res.json(shops);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch shops' });
  }
});

/**
 * POST /api/shops
 *
 * Create a new shop. Expects `name`, `shopId`, `image`, `url`, and
 * optional `totalDistributed`.
 */
app.post('/api/shops', async (req, res) => {
  const { name } = req.body;
  if (!name) {
    return res.status(400).json({ error: 'name is required' });
  }
  try {
    const shop = await createShop(req.body);
    res.status(201).json(shop);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to create shop' });
  }
});

/**
 * PUT /api/shops/:id
 *
 * Update a shop by ID. Accepts any fields to update (name, image,
 * url, totalDistributed, etc.).
 */
app.put('/api/shops/:id', async (req, res) => {
  const { id } = req.params;
  try {
    const shop = await updateShop(id, req.body);
    res.json(shop);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to update shop' });
  }
});

/**
 * DELETE /api/shops/:id
 *
 * Remove a shop by its ID.
 */
app.delete('/api/shops/:id', async (req, res) => {
  const { id } = req.params;
  try {
    await deleteShop(id);
    res.json({ success: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to delete shop' });
  }
});

/**
 * GET /api/goldprice
 *
 * Returns the current price of gold per gram. Falls back to the constant
 * if no custom price has been set in the database.
 */
app.get('/api/goldprice', async (_req, res) => {
  try {
    const price = await getGoldPrice(GOLD_PRICE_PER_GRAM);
    res.json({ price });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch gold price' });
  }
});

/**
 * POST /api/goldprice
 *
 * Update the current gold price. Expects a `price` number in the body.
 */
app.post('/api/goldprice', async (req, res) => {
  const { price } = req.body;
  if (typeof price === 'undefined') {
    return res.status(400).json({ error: 'price is required' });
  }
  try {
    const newPrice = await setGoldPrice(price);
    res.json({ price: newPrice });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to set gold price' });
  }
});

/**
 * GET /api/orders
 *
 * Fetch a list of orders. You can optionally filter by email by passing
 * a query parameter (e.g. /api/orders?email=foo@example.com). This route
 * returns all orders by default.
 */
app.get('/api/orders', async (req, res) => {
  try {
    const orders = await listOrders(req.query.email);
    res.json(orders);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch orders' });
  }
});

/**
 * GET /api/orders/:id
 *
 * Fetch a single order by its internal id.
 */
app.get('/api/orders/:id', async (req, res) => {
  try {
    const order = await getOrder(req.params.id);
    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }
    res.json(order);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch order' });
  }
});

/**
 * PUT /api/orders/:id
 *
 * Update an existing order. You can change the purchase total (for example
 * to reflect a return) or update the status. If the purchase total is
 * updated, the reward amount and weight are recalculated.
 */
app.put('/api/orders/:id', async (req, res) => {
  const { totalPrice, status } = req.body;
  try {
    // First fetch the existing order
    const existing = await getOrder(req.params.id);
    if (!existing) {
      return res.status(404).json({ error: 'Order not found' });
    }
    const updates = {};
    if (typeof totalPrice !== 'undefined') {
      const newTotal = parseFloat(totalPrice);
      updates.purchaseTotal = newTotal;
      updates.rewardAmount = newTotal * REWARD_PERCENTAGE;
      updates.rewardGrams = updates.rewardAmount / GOLD_PRICE_PER_GRAM;
    }
    if (status) {
      updates.status = status;
    }
    const updated = await updateOrder(req.params.id, updates);
    res.json(updated);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to update order' });
  }
});

/**
 * POST /api/redemptions
 *
 * Create a new redemption request. The request body should contain the
 * customer's email and the number of grams they wish to redeem (or an
 * equivalent rupee amount if you prefer). The request is added to the
 * database with a status of "pending". An admin can later approve it.
 */
app.post('/api/redemptions', async (req, res) => {
  const { email, grams, amount } = req.body;
  if (!email || (!grams && !amount)) {
    return res
      .status(400)
      .json({ error: 'email and grams or amount are required.' });
  }
  // If the request supplies an amount, convert it to grams using the
  // configured gold price. Otherwise use the provided grams directly.
  const requestedGrams =
    typeof grams !== 'undefined'
      ? parseFloat(grams)
      : parseFloat(amount) / GOLD_PRICE_PER_GRAM;
  try {
    const record = await createRedemption({
      email,
      grams: requestedGrams,
      amount: requestedGrams * GOLD_PRICE_PER_GRAM,
      status: 'pending',
      createdAt: new Date().toISOString(),
      approvedAt: null,
    });
    res.status(201).json(record);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to create redemption' });
  }
});

/**
 * GET /api/redemptions
 *
 * Retrieve a list of redemption requests. You can filter by email via a
 * query parameter (e.g. /api/redemptions?email=foo@example.com).
 */
app.get('/api/redemptions', async (req, res) => {
  try {
    const redemptions = await listRedemptions(req.query.email);
    res.json(redemptions);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch redemptions' });
  }
});

/**
 * PUT /api/redemptions/:id/approve
 *
 * Approve a redemption request. This endpoint sets the status to "approved"
 * and records the approval timestamp. In a real application you would
 * trigger a payout or other side‑effect here.
 */
app.put('/api/redemptions/:id/approve', async (req, res) => {
  try {
    const updated = await approveRedemption(req.params.id);
    if (!updated) {
      return res.status(404).json({ error: 'Redemption request not found' });
    }
    res.json(updated);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to approve redemption' });
  }
});

/**
 * POST /api/queries
 *
 * Create a new contact query. Expects the request body to contain the
 * sender’s name, brand, email, (optional) website and their message.
 * Stores the record in Firestore and returns the saved object. The
 * server assigns a timestamp and a custom ID internally.
 */
app.post('/api/queries', async (req, res) => {
  const { name, brand, email, website, message } = req.body;
  if (!name || !brand || !email || !message) {
    return res
      .status(400)
      .json({ error: 'name, brand, email and message are required' });
  }
  try {
    const saved = await createQuery({
      name,
      brand,
      email,
      website: website || '',
      message,
      createdAt: new Date().toISOString(),
    });
    res.status(201).json(saved);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to submit query' });
  }
});

/**
 * GET /api/queries
 *
 * Fetch all contact queries. Returns an array of query objects. The
 * results are sorted by creation date in descending order before being
 * returned so that newer submissions appear first.
 */
app.get('/api/queries', async (_req, res) => {
  try {
    const queries = await listQueries();
    queries.sort((a, b) => {
      const tA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
      const tB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
      return tB - tA;
    });
    res.json(queries);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch queries' });
  }
});

/**
 * DELETE /api/orders/:id
 *
 * Permanently delete an order record from the database. Use with caution.
 */
app.delete('/api/orders/:id', async (req, res) => {
  try {
    await deleteOrder(req.params.id);
    res.json({ success: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to delete order' });
  }
});

/**
 * GET /api/orders/:id/status
 *
 * Retrieve the status of an order. Currently returns the stored `status`
 * field from Firestore. In a production system this endpoint could
 * integrate with the Shopify Admin API to fetch the latest status (e.g.
 * to determine whether an order was returned). For now it simply
 * echoes the order document's status.
 */
app.get('/api/orders/:id/status', async (req, res) => {
  try {
    const order = await getOrder(req.params.id);
    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }
    res.json({ status: order.status || 'unknown' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch order status' });
  }
});

// Fallback route: if no API or static file matches, serve the admin page. In a
// Serve named pages for dashboard and admin routes
// The landing page is served from the root path. Without this route,
// the catch‑all fallback below would send the admin page for '/' due to the
// wildcard match. Defining '/' explicitly ensures that visiting the base
// domain displays our marketing landing page (index.html) instead.
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.get('/dashboard', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'dashboard.html'));
});
app.get('/admin', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'admin.html'));
});

// Fallback route: if no API or static file matches, serve the admin page by default.
app.get('*', (_req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'admin.html'));
});

app.listen(PORT, () => {
  console.log(`Digital Gold app listening on port ${PORT}`);
});